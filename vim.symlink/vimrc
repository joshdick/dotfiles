" vim:fdm=marker
set encoding=utf-8

function! s:SourceConfigFilesIn(directory)
  let directory_splat = '~/.vim/' . a:directory . '/*'
  for config_file in split(glob(directory_splat), '\n')
    if filereadable(config_file)
      execute 'source' config_file
    endif
  endfor
endfunction

runtime config/core.vim
call s:SourceConfigFilesIn('config/misc')
call s:SourceConfigFilesIn('config/plugins')

"Functions/Miscellaneous {{{

"Highlight Trailing Whitespace {{{

"Adapted from <http://vim.wikia.com/wiki/Highlight_unwanted_spaces>
" * Inside insert mode, don't match trailing whitespace on the current line.
" * Outside insert mode, match all trailing whitespace on the current line.
let ExtraWhitespace_cterm = synIDattr(synIDtrans(hlID('Error')), 'fg', 'cterm')
let ExtraWhitespace_gui = synIDattr(synIDtrans(hlID('Error')), 'fg', 'gui')
exe 'highlight ExtraWhitespace ctermbg=' . ExtraWhitespace_cterm . ' guibg=' . ExtraWhitespace_gui
match ExtraWhitespace /\s\+$/
if has("autocmd")
  augroup whitespace_highlighting
    autocmd!
    autocmd ColorScheme * let ExtraWhitespace_cterm = synIDattr(synIDtrans(hlID('Error')), 'fg', 'cterm')
    autocmd ColorScheme * let ExtraWhitespace_gui = synIDattr(synIDtrans(hlID('Error')), 'fg', 'gui')
    autocmd ColorScheme * exe 'highlight ExtraWhitespace ctermbg=' . ExtraWhitespace_cterm . ' guibg=' . ExtraWhitespace_gui
    autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
    autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
    autocmd InsertLeave * match ExtraWhitespace /\s\+$/
    autocmd BufWinLeave * call clearmatches()
  augroup END
endif

"}}}

"Super Retab {{{

"Found at <http://vim.wikia.com/wiki/Super_retab>

"  Space2Tab  Convert spaces to tabs, only in indents.
"  Tab2Space  Convert tabs to spaces, only in indents.
"  RetabIndent  Execute Space2Tab (if 'expandtab' is set), or Tab2Space (otherwise).
"Each command accepts an argument that specifies the number of spaces in a tab column. By default, the 'tabstop' setting is used.

"Return indent (all whitespace at start of a line), converted from
"tabs to spaces if what=1, or from spaces to tabs otherwise.
"When converting to tabs, result has no redundant spaces.
function! Indenting(indent, what, cols)
  let spccol=repeat(' ', a:cols)
  let result=substitute(a:indent, spccol, '\t', 'g')
  let result=substitute(result, ' \+\ze\t', '', 'g')
  if a:what == 1
    let result=substitute(result, '\t', spccol, 'g')
  endif
  return result
endfunction

"Convert whitespace used for indenting (before first non-whitespace).
"what=0 (convert spaces to tabs), or 1 (convert tabs to spaces).
"cols=string with number of columns per tab, or empty to use 'tabstop'.
"The cursor position is restored, but the cursor will be in a different
"column when the number of characters in the indent of the line is changed.
function! IndentConvert(line1, line2, what, cols)
  let savepos=getpos('.')
  let cols=empty(a:cols) ? &tabstop : a:cols
  execute a:line1 . ',' . a:line2 . 's/^\s\+/\=Indenting(submatch(0), a:what, cols)/e'
  call histdel('search', -1)
  call setpos('.', savepos)
endfunction

command! -nargs=? -range=% Space2Tab call IndentConvert(<line1>,<line2>,0,<q-args>)
command! -nargs=? -range=% Tab2Space call IndentConvert(<line1>,<line2>,1,<q-args>)
command! -nargs=? -range=% RetabIndent call IndentConvert(<line1>,<line2>,&et,<q-args>)

"}}}

"Drop-down Persistent Terminal for NeoVim {{{

"Found at <https://pastebin.com/FjdkegRH>

if has("nvim")

  function! ChooseTerm(termname, slider)
    let pane = bufwinnr(a:termname)
    let buf = bufexists(a:termname)
    if pane > 0
      " pane is visible
      if a:slider > 0
        :exe pane . "wincmd c"
      else
        :exe "e #"
      endif
    elseif buf > 0
      " buffer is not in pane
      if a:slider
        :exe "topleft split"
      endif
      :exe "buffer " . a:termname
    else
      " buffer is not loaded, create
      if a:slider
        :exe "topleft split"
      endif
      :terminal
      :exe "f " a:termname
    endif
  endfunction

  " Toggle 'default' terminal
  nnoremap <leader>t :call ChooseTerm("term-slider", 1)<CR>

  " Start terminal in current pane
  nnoremap <leader>T :call ChooseTerm("term-pane", 0)<CR>

endif

"}}}

"Automatic Working Directory {{{

"Adapted from <http://inlehmansterms.net/2014/09/04/sane-vim-working-directories/>

" If in a Git repo, sets the working directory to its root,
" or if not, to the directory of the current file.
function! SetWorkingDirectory()
  " Default to the current file's directory (resolving symlinks.)
  let current_file = expand('%:p')
  if getftype(current_file) == 'link'
    let current_file = resolve(current_file)
  endif
  exe ':lcd' . fnamemodify(current_file, ':h')

  " Get the path to `.git` if we're inside a Git repo.
  " Works both when inside a worktree, or inside an internal `.git` folder.
  :silent let git_dir = system('git rev-parse --git-dir')[:-2]
  " Check whether the command output starts with 'fatal'; if it does, we're not inside a Git repo.
  let is_not_git_dir = matchstr(git_dir, '^fatal:.*')
  " If we're inside a Git repo, change the working directory to its root.
  if empty(is_not_git_dir)
    " Expand path -> Remove trailing slash -> Remove trailing `.git`.
    exe ':lcd' . fnamemodify(git_dir, ':p:h:h')
  endif
endfunction

if has("autocmd")
  augroup working_directory
    autocmd!
    autocmd BufRead * call SetWorkingDirectory()
  augroup END
endif

"}}}

"Automatic Helptags Generation {{{

"Disabled in favor of update() function in `~/.zsh/functions.zsh`,
"since this doesn't really need to run every time Vim starts.

" function! GenerateHelpTags()
  " silent! helptags ALL
" endfunction

" if v:vim_did_enter
  " call s:GenerateHelpTags
" else
  " if has("autocmd")
    " augroup generate_helptags
      " autocmd!
      " autocmd VimEnter * call GenerateHelpTags()
    " augroup END
  " endif
" endif

"}}}

"Miscellaneous {{{

"Shows the syntax highlighting group used at the cursor.
"Found at <http://vim.wikia.com/wiki/Identify_the_syntax_highlighting_group_used_at_the_cursor>
map <F10> :echo "hi<". synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
  \ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
  \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

"Runs arbitrary commands while preserving state.
"Found at <http://technotales.wordpress.com/2010/03/31/preserve-a-vim-function-that-keeps-your-state/>
function! Preserve(command)
  "Preparation: save last search, and cursor position.
  let _s=@/
  let l=line(".")
  let c=col(".")
  "Do the business:
  execute a:command
  "Clean up: restore previous search history, and cursor position
  let @/=_s
  call cursor(l, c)
endfunction

"Converts mixed line endings to LF-only (Unix.)
"Found at <http://vim.wikia.com/wiki/File_format>
function! ForceLF()
  :update
  :e ++ff=dos
  :setlocal ff=unix
  :w
endfunction

"}}}

"}}}
